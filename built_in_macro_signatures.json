{
    "name": {
        "variant": "Function",
        "name": "name",
        "args": [
            "a_path"
        ],
        "expr": "$name(a_path)",
        "desc": "Get a name from a given path including an extension\n\n# Return : path\n\n# Arguments\n\n- a_path : Path to get a name from\n\n# Example\n\n$assert(auto.sh,$name(/path/to/file/auto.sh))"
    },
    "forby": {
        "variant": "Deterred",
        "name": "forby",
        "args": [
            "a_body",
            "a_sep",
            "a_text"
        ],
        "expr": "$forby(a_body,a_sep,a_text)",
        "desc": "Iterate around text separated by separator.\n\nIterated value is bound to macro \":\"\n\n# Arguments\n\n- a_body : Body to be pasted as iterated item\n- a_sep  : Separator to split an ar\n- a_text : Text to split by separator\n\n# Example\n\n$assert(a+b+c+,$forby($:()+,-,a-b-c))"
    },
    "wrap": {
        "variant": "Function",
        "name": "wrap",
        "args": [
            "a_width^",
            "a_text"
        ],
        "expr": "$wrap(a_width^,a_text)",
        "desc": "Wrap texts by width\n\n# Arguments\n\n- a_width : Width(chars) of given texts ( trimmed )\n- a_text  : Text to wrap\n\n# Example\n\n$assert(\\*Lorem ipsum\ndolor sit amet,\nconsectetur\nadipiscing elit. In\nrhoncus*\\,$wrap(20,$lipsum(10)))"
    },
    "evalk": {
        "variant": "Function",
        "name": "evalk",
        "args": [
            "a_expr"
        ],
        "expr": "$evalk(a_expr)",
        "desc": "Evaluate an expression while keeping source texts\n\n- This macro redirects expression to evalexpr crate\n\n# Arguments\n\n- a_expr : Expression to evaluate\n\n# Example\n\n$assert(1 + 2 = 3,$evalk(1 + 2 ))"
    },
    "spilt": {
        "variant": "Function",
        "name": "spilt",
        "args": [
            "a_sep",
            "a_text"
        ],
        "expr": "$spilt(a_sep,a_text)",
        "desc": "Split text into an array\n\n# Arguments\n\n- a_sep  : Separator\n- a_text : Text to spilt\n\n# Example\n\n$assert(\\*a,b,c*\\,$split(/,a/b/c))"
    },
    "halt": {
        "variant": "Function",
        "name": "halt",
        "args": [],
        "expr": "$halt()",
        "desc": "Halt relaying\n\n- NOTE : Halt is automatically queued by default. Feed boolean argument to configure this behaviour\n- $halt(false) == $halt()\n\n# Example\n\n$define(cont=)\n$relay(macro,cont)\n12345\n$halt()\n$assert(12345,$cont^())"
    },
    "count": {
        "variant": "Function",
        "name": "count",
        "args": [
            "a_array"
        ],
        "expr": "$count(a_array)",
        "desc": "Get counts of an array\n\n# Return : Unsigned integer\n\n# Arguments\n\n- a_array : An array to get counts from\n\n# Example\n\n$assert($count(a,b,c),3)"
    },
    "lipsum": {
        "variant": "Function",
        "name": "lipsum",
        "args": [
            "a_word_count^"
        ],
        "expr": "$lipsum(a_word_count^)",
        "desc": "Create a placeholder text. The order of placeholder is always same.\n\n# Arguments\n\n- a_word_count : Word counts of placeholder ( trimmed )\n\n# Example\n\n$assert(Lorem ipsum dolor,$lipsum(3))"
    },
    "assert": {
        "variant": "Function",
        "name": "assert",
        "args": [
            "a_lvalue",
            "a_rvalue"
        ],
        "expr": "$assert(a_lvalue,a_rvalue)",
        "desc": "Compare lvalue and rvalue, panics with two values are not equal\n\n# Arguments\n\n- a_lvalue : Left  value to compare\n- a_rvalue : Right value to compare\n\n# Example\n\n% Succeed\n$assert(1,1)\n% Fails\n$assert(a,b)"
    },
    "min": {
        "variant": "Function",
        "name": "min",
        "args": [
            "a_array"
        ],
        "expr": "$min(a_array)",
        "desc": "Get min value from a given array\n\n # Arguments\n\n- a_array : Array to get the lowest order from\n\n# Example\n\n$assert(aIsSmall,$min(aIsSmall,cIsMiddle,eIsBigger))\n$assert(1,$min(1,2,3,4,5))"
    },
    "declare": {
        "variant": "Function",
        "name": "declare",
        "args": [
            "a_macro_names"
        ],
        "expr": "$declare(a_macro_names)",
        "desc": "Declare multiple variables separated by commas\n\n# Arguments\n\n- a_macro_names: Macro names array\n\n# Example\n\n$declare(first,second)\n$assert($first(),$empty())"
    },
    "input": {
        "variant": "Function",
        "name": "input",
        "args": [
            "a_absolute?^"
        ],
        "expr": "$input(a_absolute?^)",
        "desc": "Print current file input.\n\n# Return : Path\n\n# Arguments\n\n- a_absolute : Whether to print input path as absolute [boolean] ( trimmed )\n\n# Example\n\n$assert($input(),test)\n$assert($input(true),/home/user/dir/test)"
    },
    "readin": {
        "variant": "Deterred",
        "name": "readin",
        "args": [
            "a_file?^"
        ],
        "expr": "$readin(a_file?^)",
        "desc": "Read from a file\n\nReadin can be only executed on first level or say, readin cannot be used inside other macros\n\n# Arguments\n\n- a_file : File to read from ( trimmed )\n\n# Example\n\n$readto(from.txt,into.txt)"
    },
    "fassert": {
        "variant": "Deterred",
        "name": "fassert",
        "args": [
            "a_expr"
        ],
        "expr": "$fassert(a_expr)",
        "desc": "Assert succeedes when text expansion yields error\n\n# Arguments\n\n- a_expr: Expression to audit\n\n# Example\n\n$fassert($eval(Text is not allowd))"
    },
    "surr": {
        "variant": "Function",
        "name": "surr",
        "args": [
            "a_start_pair",
            "a_end_pair",
            "a_content"
        ],
        "expr": "$surr(a_start_pair,a_end_pair,a_content)",
        "desc": "Surround given content with given pair\n\n# Arguments\n\n- a_start_pair : Start pair\n- a_end_pair   : End pair\n- a_content    : Text to surround with\n\n# Example\n\n$assert(<div>dividivi dip</div>,$enl()\n$surr(<div>,</div>,dividivi dip))"
    },
    "forline": {
        "variant": "Deterred",
        "name": "forline",
        "args": [
            "a_body",
            "a_lines"
        ],
        "expr": "$forline(a_body,a_lines)",
        "desc": "Loop around given lines separated by newline chraracter. \n\nIterated value is bound to macro \":\"\n \n# Arguments\n\n- a_body  : Body to be pasted as iterated item\n- a_lines : Lines to iterate\n\n# Example\n\n$assert(a+b+c+,$forline($:()+,a$nl()b$nl()c))"
    },
    "sort": {
        "variant": "Function",
        "name": "sort",
        "args": [
            "a_sort_type^",
            "a_array"
        ],
        "expr": "$sort(a_sort_type^,a_array)",
        "desc": "Sort an array\n\n# Arguments\n\n- a_sort_type : Sor type [\"asec\",\"desc\"] (trimmed)\n- a_array     : Array to sort\n\n# Example\n\n$assert(\\*0,1,3,4,6,7,9*\\,$enl()\n$sort(asec,3,6,7,4,1,9,0))"
    },
    "fileout": {
        "variant": "Function",
        "name": "fileout",
        "args": [
            "a_filename^",
            "a_truncate?^",
            "a_content"
        ],
        "expr": "$fileout(a_filename^,a_truncate?^,a_content)",
        "desc": "Write content to a file\n\n# Auth : FOUT\n\n# Arguments\n\n# Example\n"
    },
    "foreach": {
        "variant": "Deterred",
        "name": "foreach",
        "args": [
            "a_body",
            "a_array"
        ],
        "expr": "$foreach(a_body,a_array)",
        "desc": "Iterate around given array.\n\nIterated value is bound to macro \":\"\n \n# Arguments\n\n- a_body  : Body to be pasted as iterated item\n- a_array : An array to iterate\n\n# Example\n\n$assert(a+b+c+,$foreach($:()+,a,b,c))"
    },
    "ifdefel": {
        "variant": "Deterred",
        "name": "ifdefel",
        "args": [
            "a_macro_name^",
            "a_if_expr",
            "a_else_expr"
        ],
        "expr": "$ifdefel(a_macro_name^,a_if_expr,a_else_expr)",
        "desc": "Execute expressions whether macro is defined or not\n\n# Arguments\n\n- a_macro_name : Macro name to check ( trimmed )\n- a_if_expr    : Expression to expand if macro is defined\n- a_else_epxr  : Expression to expand if macro is NOT defined\n\n# Example\n\n$assert(I'm defined,$ifdefel(define,I'm defined,I'm NOT defined))\n$assert(I'm NOT defined,$ifdefel(defuo,I'm defined,I'm NOT defined))"
    },
    "log": {
        "variant": "Function",
        "name": "log",
        "args": [
            "a_msg"
        ],
        "expr": "$log(a_msg)",
        "desc": "Log a message to console\n\n# Arguments\n\n- a_msg : Message to log to console\n\n# Example\n\n$log($value_i_want_to_check^())"
    },
    "hygiene": {
        "variant": "Function",
        "name": "hygiene",
        "args": [
            "a_hygiene?"
        ],
        "expr": "$hygiene(a_hygiene?)",
        "desc": "Toggle hygiene mode. This enables macro hygiene.\n\n- On \"macro\" hygiene, every newly defined runtime macros are all cleared after first level macro invocation.\n\n# Arguments\n\n- a_hygiene : Whether to enable a macro hygiene mode [boolean] (trimmed)\n\n# Example\n\n$hygiene(true)\n$define(test=Test)\n% test macro is cleared and doesn't exsit\n$fassert($test())"
    },
    "sub": {
        "variant": "Function",
        "name": "sub",
        "args": [
            "a_start_index^",
            "a_end_index^",
            "a_source"
        ],
        "expr": "$sub(a_start_index^,a_end_index^,a_source)",
        "desc": "Get a substring with indices. \n\n- Out of range index is error\n- Substring is calculated as char iterator not a byte iterator\n- this operation is technically same with string[start_index..end_index]\n\n# Arguments\n\n- a_start_index : Start substring index [Unsigned integer] (trimmed)\n- a_end_index   : End   substring index [Unsigned integer] (trimmed)\n- a_source      : Source text get substring from\n\n# Example\n\n$assert(def,$sub(3,5,abcdef))"
    },
    "relay": {
        "variant": "Function",
        "name": "relay",
        "args": [
            "a_target_type^",
            "a_target^+"
        ],
        "expr": "$relay(a_target_type^,a_target^+)",
        "desc": "Start relaying to target which redirects all following texts to relay target.\n\n# Auth : FOUT required for relay target \"file\" and \"temp\"\n\n# Arguments\n\n- a_target_type : A type of a relay target [\"macro\",\"file\", \"temp\"] (trimmed)\n- a_target      : Name of target. Ignored in temp type\n\n# Example\n\n$relay(file,out.md)$halt()\n$relay(macro,container)$halt()\n$relay(temp)$halt()"
    },
    "hms": {
        "variant": "Function",
        "name": "hms",
        "args": [
            "a_second^"
        ],
        "expr": "$hms(a_second^)",
        "desc": "Get given sesconds in hh:mm:ss format\n\n# Arguments\n\n- a_second : Seconds to convert\n\n# Example\n\n$assert(00:33:40,$hms(2020))"
    },
    "space": {
        "variant": "Function",
        "name": "space",
        "args": [
            "a_amount?^"
        ],
        "expr": "$space(a_amount?^)",
        "desc": "Print spaces\n\n# Arguments\n\n- a_amount : Amount of spaces [Unsigned integer] ( trimmed )\n\n# Example\n\n$assert(    ,$space(4))"
    },
    "prec": {
        "variant": "Function",
        "name": "prec",
        "args": [
            "a_number^",
            "a_precision^"
        ],
        "expr": "$prec(a_number^,a_precision^)",
        "desc": "Convert a float number with a given precision\n\n# Return : Float\n\n# Arguments\n\n- a_number    : Number to process ( trimmed )\n- a_precision : Precision to apply to number ( trimmed )\n\n# Example\n\n$assert(0.30,$prec($eval(0.1 + 0.2),2))"
    },
    "head": {
        "variant": "Function",
        "name": "head",
        "args": [
            "a_count^",
            "a_content"
        ],
        "expr": "$head(a_count^,a_content)",
        "desc": "Crop head texts from given content\n\n# Arguments\n\n- a_count   : Amount of characters to crop [unsigned integer] ( trimmed )\n- a_content : Text to crop from\n\n# Example\n\n$assert(Hello~,$head( 6 ,Hello~ World))"
    },
    "not": {
        "variant": "Function",
        "name": "not",
        "args": [
            "a_boolean?^"
        ],
        "expr": "$not(a_boolean?^)",
        "desc": "Return a negated value of a given boolean. Yield error when given value is not a boolean\n\n# Return : boolean\n\n# Arguments\n\n- a_boolean : Boolean value to negate [boolean] ( trimmed )\n\n# Example\n\n$assert(false,$not(true))\n$assert(true,$not(false))\n$assert(false,$not(1))\n$assert(true,$not(0))"
    },
    "forloop": {
        "variant": "Deterred",
        "name": "forloop",
        "args": [
            "a_body",
            "a_min^",
            "a_max^"
        ],
        "expr": "$forloop(a_body,a_min^,a_max^)",
        "desc": "Iterate around given range (min,max). \n\nIterated value is bound to macro \":\" \n\n# Arguments\n\n- a_body : Body to be pasted as iterated item\n- a_min  : Start index ( trimmed )\n- a_max  : End index ( trimmed )\n\n# Example\n\n$assert(1+2+3+,$forloop($:()+,1,3))"
    },
    "lower": {
        "variant": "Function",
        "name": "lower",
        "args": [
            "a_text"
        ],
        "expr": "$lower(a_text)",
        "desc": "Get lowercase english texts\n\n# Arguments\n\n- a_text: Text to transform\n\n# Example\n\n$assert(abcde,$lower(AbCdE))"
    },
    "source": {
        "variant": "Function",
        "name": "source",
        "args": [
            "a_file^"
        ],
        "expr": "$source(a_file^)",
        "desc": "Source an env file. Sourced file is eagerly expanded (As if it was static defined)\n\nSyntax of source-able file is same with .env file\n\ne.g)\ndemo=DEMO\nnumber=$eval(1+2)\n\n# Arguments\n\n- a_file : File to source ( trimmed )\n\n# Example\n\n$source(def.env)"
    },
    "len": {
        "variant": "Function",
        "name": "len",
        "args": [
            "a_string"
        ],
        "expr": "$len(a_string)",
        "desc": "Get a length of texts. This count utf8 characters not ascii.\n\n# Return : Unsigned integer\n\n# Arguments\n\n- a_string : Text to get length from\n\n# Example\n\n$assert($len(\uac00\ub098\ub2e4),$len(ABC))"
    },
    "env": {
        "variant": "Function",
        "name": "env",
        "args": [
            "a_env_name^"
        ],
        "expr": "$env(a_env_name^)",
        "desc": "Get an environment variable\n\n# Auth : ENV\n\n# Arguments\n\n- a_env_name : Environment variable name to get (trimmed)\n\n# Example\n\n$assert(/home/user/dir,$env(HOME))"
    },
    "findm": {
        "variant": "Function",
        "name": "findm",
        "args": [
            "a_expr",
            "a_source"
        ],
        "expr": "$findm(a_expr,a_source)",
        "desc": "Find occurrences of expression from source. This return 0 if there are no occurrences\n\n# Return : Unsigned integer\n\n# Arguments\n\n- a_expr   : Expression to match\n- a_source : Source to match for\n\n# Example\n\n$assert(2,$findm(o,hello world))"
    },
    "sortl": {
        "variant": "Function",
        "name": "sortl",
        "args": [
            "a_sort_type^",
            "a_lines"
        ],
        "expr": "$sortl(a_sort_type^,a_lines)",
        "desc": "Sort lines\n\n# Arguments\n\n- a_sort_type : Sor type [\"asec\",\"desc\"] (trimmed)\n- a_lines     : Lines to sort\n\n# Example\n\n$assert(f$nl()e$nl()d$nl()c,$sortl(desc,f\ne\nd\nc))"
    },
    "join": {
        "variant": "Function",
        "name": "join",
        "args": [
            "a_sep",
            "a_array"
        ],
        "expr": "$join(a_sep,a_array)",
        "desc": "Join an array into a single chunk\n\n# Arguments\n\n- a_sep   : Separator used for joining\n- a_array : Source to array to join\n\n# Example\n\n$assert(a-b-c,$join(-,a,b,c))"
    },
    "readto": {
        "variant": "Deterred",
        "name": "readto",
        "args": [
            "a_from_file^",
            "a_to_file^"
        ],
        "expr": "$readto(a_from_file^,a_to_file^)",
        "desc": "Read from a file and paste into a file\n\nReadto can be only executed on first level or say, readto cannot be used inside other macros\n\n# Arguments\n\n- a_from_file : File to read from ( trimmed )\n- a_to_file   : File to paste into ( trimmed )\n\n# Example\n\n$readto(from.txt,into.txt)"
    },
    "import": {
        "variant": "Function",
        "name": "import",
        "args": [
            "a_file^"
        ],
        "expr": "$import(a_file^)",
        "desc": "Import a frozen file at runtime\n\n- Import always include the macros as non-volatile form, thus never cleared unless accessed as library\n\n# Arguments\n\n- a_file: File name to import from [path] (trimmed) \n\n# Example\n\n$import(def.r4f)"
    },
    "floor": {
        "variant": "Function",
        "name": "floor",
        "args": [
            "a_number^"
        ],
        "expr": "$floor(a_number^)",
        "desc": "Get floor integer from a given number\n\n# Return : Signed integer\n\n# Arguments\n\n- a_number : Number to get a floor from [float] ( trimmed )\n\n# Example\n\n$assert($floor( 1.9),1)\n$assert($floor(-3.1),-4)"
    },
    "parent": {
        "variant": "Function",
        "name": "parent",
        "args": [
            "a_path"
        ],
        "expr": "$parent(a_path)",
        "desc": "Get a parent from a given path. \n\n- NOTE : This yields error if path is root and will return empty value, not a none value if path is a single node.\n\n# Return : path\n\n# Arguments\n\n- a_path : A Path to extract parent from\n\n# Example \n\n$fassert($parent(/))\n$assert($empty(),$parent(node))\n$assert(/first/second,$parent(/first/second/last.txt))"
    },
    "ifelse": {
        "variant": "Deterred",
        "name": "ifelse",
        "args": [
            "a_cond?^",
            "a_if_expr",
            "a_else_expr"
        ],
        "expr": "$ifelse(a_cond?^,a_if_expr,a_else_expr)",
        "desc": "Check condition and execute different expressions by the condition\n\n# Arguments\n\n- a_cond      : Condition ( trimmed )\n- a_if_expr   : Expression to expand if condition is true\n- a_else_expr : Expression to expand if condition is false\n\n# Example\n\n$assert(I'm true,$ifelse(true,I'm true,I'm false))\n$assert(I'm false,$ifelse(false,I'm true,I'm false))"
    },
    "repeat": {
        "variant": "Function",
        "name": "repeat",
        "args": [
            "a_count^",
            "a_source"
        ],
        "expr": "$repeat(a_count^,a_source)",
        "desc": "Repeat a given source by given counts\n\n# Arguments\n\n- a_count  : Counts of repetition [Unsigned integer] ( trimmed )\n- a_source : Source text to repeat\n\n# Example\n\n$assert(R4d\nR4d\nR4d,$repeat^(3,R4d$nl()))"
    },
    "comp": {
        "variant": "Function",
        "name": "comp",
        "args": [
            "a_content"
        ],
        "expr": "$comp(a_content)",
        "desc": "Apply both trim and chomp, or say compress content\n\n# Arguments\n\n- a_content : Content to compress\n\n# Example\n$staticr(lines,\n    upper\n    \n\n    down\n)\n$assert($countl($lines()),5)\n$assert($countl($comp($lines())),3)"
    },
    "table": {
        "variant": "Function",
        "name": "table",
        "args": [
            "a_table_form^",
            "a_csv_value^"
        ],
        "expr": "$table(a_table_form^,a_csv_value^)",
        "desc": "Construct a formatted table. Available table forms are \"github,html,wikitext\"\n\n# Arguments\n\n- a_table_form : Table format [ \"github\", \"html\", \"wikitext\" ]\n- a_csv_value  : Value to convert to table ( trimmed )\n\n# Example\n\n$assert=(\n\t|a|b|c|\n\t|-|-|-|\n\t|1|2|3|,$enl()\n\t$table(github,a,b,c\n\t1,2,3)\n)"
    },
    "static": {
        "variant": "Function",
        "name": "static",
        "args": [
            "a_macro_name^",
            "a_expr^"
        ],
        "expr": "$static(a_macro_name^,a_expr^)",
        "desc": "Create a static macro. Static macro is eagerly expanded unlike define\n\n# Arguments\n\n- a_macro_name : Macro to create ( trimmed )\n- a_expr       : Expression to bind to ( trimmed )\n\n# Example\n\n$define(ct=0)\n$define(ddf=$ct())\n$static(stt,$ct())\n$counter(ct)\n$counter(ct)\n$assert(2,$ddf())\n$assert(0,$stt())"
    },
    "tempin": {
        "variant": "Function",
        "name": "tempin",
        "args": [],
        "expr": "$tempin()",
        "desc": "Include a temporary file\n\n- Default temporary path is folloiwng\n- Windows : It depends, but %APPDATA%\\Local\\Temp\\rad.txt can be one\n- *nix    : /tmp/rad.txt \n\n# Auth: FIN\n\n# Example\n\n$tempin()"
    },
    "tempout": {
        "variant": "Function",
        "name": "tempout",
        "args": [
            "a_content"
        ],
        "expr": "$tempout(a_content)",
        "desc": "Write to a temporary file\n\n- Default temporary path is folloiwng\n- Windows : It depends, but %APPDATA%\\Local\\Temp\\rad.txt can be one\n- *nix    : /tmp/rad.txt \n\n# Auth: FOUT\n\n# Arguments\n\n- a_content : Content to write to temporary file\n\n# Example\n\n$temout(Content)"
    },
    "countw": {
        "variant": "Function",
        "name": "countw",
        "args": [
            "a_array"
        ],
        "expr": "$countw(a_array)",
        "desc": "Get count of words\n\n# Return : Unsigned integer\n\n# Arguments\n\n- a_array : An array to get word counts from\n\n# Example\n\n$assert($countw(hello world),2)"
    },
    "empty": {
        "variant": "Function",
        "name": "empty",
        "args": [],
        "expr": "$empty()",
        "desc": "Print nothing. Used for semantic formatting.\n\n# Example\n\n$assert( ,$empty())"
    },
    "date": {
        "variant": "Function",
        "name": "date",
        "args": [],
        "expr": "$date()",
        "desc": "Get current local date without timezone\n\n# Example\n\n% yyyy-MM-dd\n$date()"
    },
    "listdir": {
        "variant": "Function",
        "name": "listdir",
        "args": [
            "a_path+",
            "a_absolute?^+",
            "a_delim+"
        ],
        "expr": "$listdir(a_path+,a_absolute?^+,a_delim+)",
        "desc": "List a directory's files as csv. \n\n- A default path is a current working directory. \n- A defualt delimiter is comma.\n\n# Auth : FIN\n\n# Arguments\n\n- a_path     : A directory path to list files (optional)\n- a_absolute : Whether to print files as absolute form [boolean] (trimmed, optional)\n- a_delim    : A delimiter to put between items (optional)\n\n# Example\n\n$assert(15,$count($litdir()))"
    },
    "regexpr": {
        "variant": "Function",
        "name": "regexpr",
        "args": [
            "a_name",
            "a_expr"
        ],
        "expr": "$regexpr(a_name,a_expr)",
        "desc": "Register an regular expression\n\n- NOTE : Registered name will not be able to matches directly\n- Every regex operation creates regex cache, while registered expression will not be cached but saved permanently. Unregistered cache will be cleared if certain capacity reaches.\n\n# Arguments\n\n- a_name : Name of the regex expression. This is not trimmed\n- a_epxr : Expression to bind to\n\n# Example\n\n$regexpr(greeting,Hello World)\n$assert(true,$find(greeting,Hello World))\n$assert(false,$find(greeting,greetings from world))"
    },
    "EB": {
        "variant": "Deterred",
        "name": "EB",
        "args": [],
        "expr": "$EB()",
        "desc": "Escape following all blanks until not. This can only be invoked at first level\n\n# Example\n\n$EB()"
    },
    "index": {
        "variant": "Function",
        "name": "index",
        "args": [
            "a_index^",
            "a_array"
        ],
        "expr": "$index(a_index^,a_array)",
        "desc": "Get an indexed value from an array\n\n# Arguments\n\n- a_index : Index to get [Signed integer] ( trimmed )\n- a_array : Data source to index from\n\n# Example\n\n$assert(ef,$index(2,ab,cd,ef))"
    },
    "align": {
        "variant": "Function",
        "name": "align",
        "args": [
            "a_type^",
            "a_width^",
            "a_fill^",
            "a_text"
        ],
        "expr": "$align(a_type^,a_width^,a_fill^,a_text)",
        "desc": "Align texts with character filler\n\n# Arguments\n\n- a_type  : Types of alignment [\"Left\", \"right\", \"center\"] ( trimmed )\n- a_width : Total width of aligned chunk [ Unsigned integer ] ( trimmed )\n- a_fill  : A character to fill ( trimmed )\n- a_text  : Text to align\n\n# Example\n\n$assert(Hello---,$align(left  ,8,-,Hello))\n$assert(---Hello,$align(right ,8,-,Hello))\n$assert(--Hello-,$align(center,8,-,Hello))"
    },
    "dnl": {
        "variant": "Function",
        "name": "dnl",
        "args": [],
        "expr": "$dnl()",
        "desc": "Deny next newline. This technically squashes following two consequent line_ending into a single one\n\n# Example\n\n$assert(a$nl()b,a$dnl()\n\nb)"
    },
    "joinl": {
        "variant": "Function",
        "name": "joinl",
        "args": [
            "a_sep",
            "a_lines"
        ],
        "expr": "$joinl(a_sep,a_lines)",
        "desc": "Join text lines into a single line\n\n# Arguments\n\n- a_sep   : Separator used for joining\n- a_lines : Source lines to join\n\n# Example\n\n$assert(a-b-c,$joinl(-,a\nb\nc))"
    },
    "chomp": {
        "variant": "Function",
        "name": "chomp",
        "args": [
            "a_content"
        ],
        "expr": "$chomp(a_content)",
        "desc": "Remove duplicate newlines from content\n\n# Arguments\n\n- a_content: Contents to chomp\n\n# Example\n\n$staticr(lines,Upper\n\n\nDown)\n$assert($countl($lines()),4)\n$assert($countl($chomp($lines())),3)"
    },
    "enl": {
        "variant": "Function",
        "name": "enl",
        "args": [],
        "expr": "$enl()",
        "desc": "Escape following new line\n\n# Example\n\n$assert(ab,a$enl()\nb)"
    },
    "dropcsv": {
        "variant": "Function",
        "name": "dropcsv",
        "args": [
            "a_table_name^"
        ],
        "expr": "$dropcsv(a_table_name^)",
        "desc": "Drop a csv table\n\n# Arguments\n\n- a_table_name : A csv table name to drop ( trimmed )\n\n# Example\n\n$dropcsv(table1)"
    },
    "headl": {
        "variant": "Function",
        "name": "headl",
        "args": [
            "a_count^",
            "a_lines"
        ],
        "expr": "$headl(a_count^,a_lines)",
        "desc": "Crop head texts but as lines from given content\n\n# Arguments\n\n- a_count   : Amount of lines to crop [unsigned integer] ( trimmed )\n- a_lines   : Lines to crop from\n\n# Example\n\n$assert(2,$countl($headl( 2 ,a\nb\nc)))"
    },
    "unicode": {
        "variant": "Function",
        "name": "unicode",
        "args": [
            "a_value^"
        ],
        "expr": "$unicode(a_value^)",
        "desc": "Creates a unicode character from given hex number without prefix\n\n# Arguments\n\n- a_value : Value to convert to unicode character\n\n# Example\n\n$assert(\u263a,$unicode(263a))"
    },
    "clear": {
        "variant": "Function",
        "name": "clear",
        "args": [],
        "expr": "$clear()",
        "desc": "Clear volatile macros. This macro is intended to be used when hygiene mode is enabled and user wants to clear volatile on right away without waiting.\n\n# Example\n\n$clear()"
    },
    "nl": {
        "variant": "Function",
        "name": "nl",
        "args": [
            "a_amount+^"
        ],
        "expr": "$nl(a_amount+^)",
        "desc": "A platform specific newline. It's behaviour can be configured.\n\n# Arguments\n\n- a_amount : Amount of newlines [Unsigned integer] ( trimmed )\n\n# Example\n\n% This may not hold true if a newline is configured by a user\n$assert($nl(),\n)"
    },
    "indent": {
        "variant": "Function",
        "name": "indent",
        "args": [
            "a_indenter",
            "a_lines"
        ],
        "expr": "$indent(a_indenter,a_lines)",
        "desc": "Indent lines with indenter\n\n# Arguments\n\n- a_indenter : Pattern to put before lines\n- a_lines    : Liens to prepend indenter\n\n# Example\n\n$assert(\n# First\n# Second\n# Third,\n$indent(# ,First\nSecond\nThird))"
    },
    "if": {
        "variant": "Deterred",
        "name": "if",
        "args": [
            "a_cond?^",
            "a_if_expr"
        ],
        "expr": "$if(a_cond?^,a_if_expr)",
        "desc": "Check condition and then execute the expression if the condition is true\n\n# Arguments\n\n- a_cond    : Condition ( trimmed )\n- a_if_expr : Expression to expand if condition is true\n\n# Example\n\n$assert(I'm true,$if(true,I'm true))"
    },
    "panic": {
        "variant": "Function",
        "name": "panic",
        "args": [
            "a_msg"
        ],
        "expr": "$panic(a_msg)",
        "desc": "Panics manually with message\n\n# Arguments\n\n- a_msg : A message to print as error\n\n# Example\n\n$panic(This should not be reached)"
    },
    "counter": {
        "variant": "Function",
        "name": "counter",
        "args": [
            "a_macro_name^",
            "a_counter_type^+"
        ],
        "expr": "$counter(a_macro_name^,a_counter_type^+)",
        "desc": "Increae/decrease counter macro. Counter's value should be a number and can be negative. \n\n# Arguments\n\n- a_macro_name   : Macro name to use as counter ( trimmed )\n- a_counter_type : Counter opration type. Dfault is plus [ \"plus\", \"minus\" ]\n\n# Example\n\n$define(ct=0)\n$counter(ct)\n$counter(ct)\n$counter(ct,minus)\n$assert($ct(),3)\n\n$counter(ct,minus)\n$assert($ct(),2)"
    },
    "exit": {
        "variant": "Function",
        "name": "exit",
        "args": [],
        "expr": "$exit()",
        "desc": "Exit processing from invocation\n\n- NOTE : This flow control only sustains for the processing\n\n# Example\n\n$exit()"
    },
    "max": {
        "variant": "Function",
        "name": "max",
        "args": [
            "a_array"
        ],
        "expr": "$max(a_array)",
        "desc": "Get max value from a given array\n# Arguments\n\n- a_array : Array to get the highest order from\n\n# Example\n\n$assert(eIsBigger,$max(aIsSmall,cIsMiddle,eIsBigger))\n$assert(5,$max(1,2,3,4,5))"
    },
    "que": {
        "variant": "Deterred",
        "name": "que",
        "args": [
            "a_expr"
        ],
        "expr": "$que(a_expr)",
        "desc": "Que expressions. Queued expressions are expanded when the macro finishes\n\nUse que macro when a macro does operations that do not return a string AND you need to make sure the operation should happen only after all string manipulation ended. Halt is queued by default.\n\nQue does not evalute inner contents and simply put expression into a queue.\n\n# Arguments\n\n- a_expr : Expression to queue\n\n# Example\n\n$que(halt(false))"
    },
    "regex": {
        "variant": "Function",
        "name": "regex",
        "args": [
            "a_expr",
            "a_sub",
            "a_source"
        ],
        "expr": "$regex(a_expr,a_sub,a_source)",
        "desc": "Apply regular expression substitution to a source\n\n# Arguments\n\n- a_expr   : Regex expression to match\n- a_sub    : Text to substitute as\n- a_source : Sourec text to operate on\n\n# Example\n\n$assert(Hello Rust,$regex(World,Rust,Hello World))"
    },
    "envset": {
        "variant": "Function",
        "name": "envset",
        "args": [
            "a_env_name^",
            "a_env_value"
        ],
        "expr": "$envset(a_env_name^,a_env_value)",
        "desc": "Set an environment variable\n\n# Auth : ENV\n\n# Arguments\n\n- a_env_name  : Environment variable name to set (trimmed)\n- a_env_value : Value to set\n\n# Example\n\n$envset(HOME,/tmp)"
    },
    "trim": {
        "variant": "Function",
        "name": "trim",
        "args": [
            "a_text"
        ],
        "expr": "$trim(a_text)",
        "desc": "Trim text. This removes leading and trailing newlines, tabs and spaces\n\n# Arguments\n\n- a_text : Text to trim\n\n# Example\n\n$assert(Middle,$trim(\n    Middle\n))"
    },
    "ifque": {
        "variant": "Deterred",
        "name": "ifque",
        "args": [
            "a_bool?^",
            "a_content"
        ],
        "expr": "$ifque(a_bool?^,a_content)",
        "desc": "If true, then queue expressions\n\nUse que macro when a macro does operations that do not return a string AND you need to make sure the operation should happen only after all string manipulation ended. Halt is queued by default.\n\nQue does not evalute inner contents and simply put expression into a queue.\n\n# Arguments\n\n- a_bool : Conditino [boolean] ( trimmed )\n- a_expr : Expression to queue\n\n# Example\n\n$ifque(true,halt(false))"
    },
    "staticr": {
        "variant": "Function",
        "name": "staticr",
        "args": [
            "a_macro_name^",
            "a_value"
        ],
        "expr": "$staticr(a_macro_name^,a_value)",
        "desc": "Create a static macro with raw value. Static macro is eagerly expanded unlike define\n\n# Arguments\n\n- a_macro_name : Macro to create ( trimmed )\n- a_expr       : Expression to bind to which is not trimmed\n\n# Example\n\n$define(ct=0)\n$define(ddf=$ct())\n$staticr(stt,$ct() )\n$counter(ct)\n$counter(ct)\n$assert(2,$ddf())\n$assert(0 ,$stt())"
    },
    "triml": {
        "variant": "Function",
        "name": "triml",
        "args": [
            "a_content"
        ],
        "expr": "$triml(a_content)",
        "desc": "Trim values by lines. Trim is applied to each lines\n\n# Arguments\n\n- a_text : Text to trim\n\n# Example\n\n$assert(Upper$nl()Middle$nl()Last,$triml(    Upper\n    Middle\n          Last))"
    },
    "define": {
        "variant": "Function",
        "name": "define",
        "args": [
            "a_define_statement"
        ],
        "expr": "$define(a_define_statement)",
        "desc": "Define a macro\n\n# Arguments\n\nDefine should follow handful of rules\n\n- Macro name, parameter name should start non number characters.\n- Consequent characters for macro names, parameter names can be underscore or any characters except special characters.\n- Parameters starts with comma and should be separated by whitespaces\n- Macro body starts with equal(=) characters\n\n# Example\n\n$define(test=Test)\n$define(demo,a_1 a_2=$a_1() $a_2())\n$assert($test(),Test)\n$assert(wow cow,$demo(wow,cow))"
    },
    "ifenv": {
        "variant": "Deterred",
        "name": "ifenv",
        "args": [
            "a_env_name^",
            "a_if_expr"
        ],
        "expr": "$ifenv(a_env_name^,a_if_expr)",
        "desc": "Execute expression if environment variable is set\n\n# Auth : ENV\n\n# Arguments\n\n- a_env_name   : Environment variable ( trimmed )\n- a_if_expr    : Expression to expand if env exists\n\n# Example\n\n$assert(I'm alive,$ifenv(HOME,I'm alive))"
    },
    "time": {
        "variant": "Function",
        "name": "time",
        "args": [],
        "expr": "$time()",
        "desc": "Get current local time\n\n# Example\n\n% HH:mm:ss\n$time()"
    },
    "fold": {
        "variant": "Function",
        "name": "fold",
        "args": [
            "a_array"
        ],
        "expr": "$fold(a_array)",
        "desc": "Fold an array into a single value\n\n# Arguments \n\n- a_array : An array to fold\n\n# Example\n\n$assert(abc,$fold(a,b,c))"
    },
    "repl": {
        "variant": "Function",
        "name": "repl",
        "args": [
            "a_macro_name^",
            "a_new_value"
        ],
        "expr": "$repl(a_macro_name^,a_new_value)",
        "desc": "Replace a macro's contents with new values\n\n# Arguments\n\n- a_macro_name : Macro name to replace\n- a_new_value  : New value to put\n\n# Example\n\n$define(demo=Demo)\n$assert(Demo,$demo())\n$repl(demo,DOMO)\n$assert(DOMO,$demo())"
    },
    "rev": {
        "variant": "Function",
        "name": "rev",
        "args": [
            "a_array"
        ],
        "expr": "$rev(a_array)",
        "desc": "Reverse an order of an array\n\n# Arguments \n\n- a_array : Array to reverse\n\n# Example\n\n$assert(\\*3,2,1*\\,$rev(1,2,3))"
    },
    "docu": {
        "variant": "Function",
        "name": "docu",
        "args": [
            "a_macro_name",
            "a_doc"
        ],
        "expr": "$docu(a_macro_name,a_doc)",
        "desc": "Append documents(description) to a macro. You cannot directly retreive documentation from macros but by --man flag.\n\n# Arguments\n\n- a_macro_name : Macro to append documentation\n- a_doc        : Document to append\n\n# Example\n\n$define(test=)\n$docu(test,This is test macro)"
    },
    "ceil": {
        "variant": "Function",
        "name": "ceil",
        "args": [
            "a_number^"
        ],
        "expr": "$ceil(a_number^)",
        "desc": "Get ceiling of a number\n\n# Return : Signed integer\n\n# Arguments\n\n- a_number : Number to get a ceiling from [float] ( trimmed )\n\n# Example\n\n$assert($ceil(0.9),1)\n$assert($ceil(3.1),4)"
    },
    "num": {
        "variant": "Function",
        "name": "num",
        "args": [
            "a_text"
        ],
        "expr": "$num(a_text)",
        "desc": "Extract a number part from given text. If there are multiple numbers, only extract the first\n# Arguments\n\n- a_text : Text to extract number from\n\n# Example\n\n$assert(34,$num(34sec))\n$assert(30,$num(30k/h for 3 hours))"
    },
    "include": {
        "variant": "Function",
        "name": "include",
        "args": [
            "a_filename^",
            "a_raw_mode^+?"
        ],
        "expr": "$include(a_filename^,a_raw_mode^+?)",
        "desc": "Include a file\n\n- Include reads a whole chunk of file into a \"Reader\" and expands\n- Use readin or readto if you want buffered behaviour\n- If raw mode is enabled include doesn't expand any macros inside the file\n\n# AUTH : FIN\n\n# Arguments\n\n- a_filename : File name to read ( trimmed )\n- a_raw_mode : Whehter to escape the read. Default is false [boolean] ( trimmed )\n\n$include(file_path)\n$include(file_path, true)"
    },
    "abs": {
        "variant": "Function",
        "name": "abs",
        "args": [
            "a_path"
        ],
        "expr": "$abs(a_path)",
        "desc": "Get an absolute path. This requires a path to be a real path.\n\n# Auth : FIN\n\n# Return : path\n\n# Arguments\n\n- a_path : Path to make it absolute\n\n# Example\n\n$assert(/home/user/cwd/test.md,$abs(test.md))"
    },
    "regcsv": {
        "variant": "Function",
        "name": "regcsv",
        "args": [
            "a_table_name^",
            "a_table"
        ],
        "expr": "$regcsv(a_table_name^,a_table)",
        "desc": "Register a csv table\n\n# Arguments\n\n- a_table_name : Table name to be registered ( trimmed )\n- a_table      : Csv data table\n\n# Example\n\n$regcsv(table1,a,b,c\n1,2,3)"
    },
    "exec": {
        "variant": "Deterred",
        "name": "exec",
        "args": [
            "a_macro_name^",
            "a_macro_args"
        ],
        "expr": "$exec(a_macro_name^,a_macro_args)",
        "desc": "Execute a macro with arguments\n\n# Arguments\n\n- a_macro_name : Macro name to exectue ( trimmed )\n- a_macro_args : Arguments to be passed to a macro\n\n# Example\n\n$assert($path(a,b,c),$exec(path,a,b,c))"
    },
    "ifdef": {
        "variant": "Deterred",
        "name": "ifdef",
        "args": [
            "a_macro_name^",
            "a_if_expr"
        ],
        "expr": "$ifdef(a_macro_name^,a_if_expr)",
        "desc": "Execute expression if macro is defined\n\n# Arguments\n\n- a_macro_name : Macro name to check ( trimmed )\n- a_if_expr    : Expression to expand if macro is defined\n\n# Example\n\n$assert(I'm defined,$ifdef(define,I'm defined))"
    },
    "syscmd": {
        "variant": "Function",
        "name": "syscmd",
        "args": [
            "a_command"
        ],
        "expr": "$syscmd(a_command)",
        "desc": "Execute an sysctem command\n\n- Each system command is executed as subprocess of folloiwng platform procedures\n- Windows : cmd /C\n- *Nix    : sh -c\n\n# Auth : CMD\n\n# Arguments\n\n- a_command : Command to exectute\n\n# Example\n\n$assert(Linux,$syscmd(uname))"
    },
    "rename": {
        "variant": "Function",
        "name": "rename",
        "args": [
            "a_macro_name^",
            "a_new_name^"
        ],
        "expr": "$rename(a_macro_name^,a_new_name^)",
        "desc": "Rename a macro with a new name\n\n# Arguments\n\n- a_macro_name : Macro to change name ( trimmed )\n- a_new_name   : New macro name to apply ( trimmed )\n\n# Example\n\n$define(test=Test)\n$rename(test,demo)\n$assert($demo(),Test)"
    },
    "letr": {
        "variant": "Function",
        "name": "letr",
        "args": [
            "a_macro_name^",
            "a_value"
        ],
        "expr": "$letr(a_macro_name^,a_value)",
        "desc": "Bind a local macro with raw value. Every local macro gets removed after first level macro expansion ends.\n\n# Arguments\n\n- a_macro_name : Binding name to make ( trimmed )\n- a_value      : A value to bind to which is not trimmed\n\n# Example\n\n$define(letr_test=\n    $letr(lc,\n        --Bound Value--\n    )\n    $assert(3,$countl($lc()))\n)\n$letr_test()\n% Cannot access local macro outside the scope\n$fassert($lc())"
    },
    "strip": {
        "variant": "Deterred",
        "name": "strip",
        "args": [
            "a_literal_expr"
        ],
        "expr": "$strip(a_literal_expr)",
        "desc": "Strip inner expression and then expand \n\n# Arguments\n\n- a_literal_expr : Expression to strip\n\n# Example\n\n$strip(\\*1,2,3*\\)"
    },
    "taill": {
        "variant": "Function",
        "name": "taill",
        "args": [
            "a_count^",
            "a_content"
        ],
        "expr": "$taill(a_count^,a_content)",
        "desc": "Get last lines of texts\n\n# Arguments\n\n- a_count   : Amount of lines to crop [unsigned integer] ( trimmed )\n- a_lines   : Lines to crop from\n\n# Example\n\n$assert(b$nl()c,$taill( 2 ,a\nb\nc))"
    },
    "pipe": {
        "variant": "Function",
        "name": "pipe",
        "args": [
            "a_pipe_name^",
            "a_value"
        ],
        "expr": "$pipe(a_pipe_name^,a_value)",
        "desc": "Pipe a given value to a named pipe\n\n# Arguments\n\n- a_pipe_name : Name of pipe container ( trimmed )\n- a_value     : Value to pipe\n\n# Example\n\n$pipeto(yum,YUM)\n$assert($-(yum),YUM)"
    },
    "update": {
        "variant": "Function",
        "name": "update",
        "args": [
            "a_text"
        ],
        "expr": "$update(a_text)",
        "desc": "Update storage\n\n# Arguments\n\n- a_text : Text to update into a storage\n\n# Example\n\n$update(text to be pushed)"
    },
    "notat": {
        "variant": "Function",
        "name": "notat",
        "args": [
            "a_number^",
            "a_notation^"
        ],
        "expr": "$notat(a_number^,a_notation^)",
        "desc": "Chagne the notaion of a number\n\n# Arguments\n\n- a_number   : A nuber to change notation\n- a_notation : A type of notation [\"bin\",\"oct\",\"hex\"] ( trimmed )\n\n# Example                        \n\n$assert(10111,$notat(23,bin))\n$assert(27,$notat(23,oct))\n$assert(17,$notat(23,hex))"
    },
    "escape": {
        "variant": "Function",
        "name": "escape",
        "args": [],
        "expr": "$escape()",
        "desc": "Escape processing from the invocation.\n\n- NOTE : This flow control only sustains for the processing.\n\n# Example\n\n$escape()"
    },
    "foldl": {
        "variant": "Function",
        "name": "foldl",
        "args": [
            "a_lines"
        ],
        "expr": "$foldl(a_lines)",
        "desc": "Fold lines into a single value\n\n# Arguments \n\n- a_lines : Lines to fold\n\n# Example\n\n$assert(abc,$foldl(a\nb\nc))"
    },
    "nassert": {
        "variant": "Function",
        "name": "nassert",
        "args": [
            "a_lvalue",
            "a_rvalue"
        ],
        "expr": "$nassert(a_lvalue,a_rvalue)",
        "desc": "Compare left and right values. Panics if lvalue is \"equal\" to rvalue\n\n# Arguments\n\n- a_lvalue : Left  value\n- a_rvalue : Right value\n\n# Example\n\n$nassert(1,2)"
    },
    "upper": {
        "variant": "Function",
        "name": "upper",
        "args": [
            "a_text"
        ],
        "expr": "$upper(a_text)",
        "desc": "Get a uppercase english text\n\n# Arguments\n\n- a_text: Text to transform\n\n# Example\n\n$assert(ABCDE,$upper(aBcDe))"
    },
    "tempto": {
        "variant": "Function",
        "name": "tempto",
        "args": [
            "a_filename^"
        ],
        "expr": "$tempto(a_filename^)",
        "desc": "Change temporary file path\n\n- This macro needs file out permission because it creates temporary file if non-existent\n\n# Auth: FOUT\n\n# Arguments\n\n- a_filename : New temporary file path ( trimmed )\n\n# Example\n\n$tempto(/new/path)"
    },
    "path": {
        "variant": "Function",
        "name": "path",
        "args": [
            "a_array^"
        ],
        "expr": "$path(a_array^)",
        "desc": "Merge given paths\n\n- This respects a platform path separator\n- Path with colliding separator cannot be merged. \n    e.g) a/ + /b cannot be merged\n\n# Return : path\n\n# Arguments\n\n- a_array : Path array to merge\n\n# Example\n\n$assert(a/b,$path(a,b))\n$assert(/a/b,$path(/a,b))\n$assert(a/b,$path(a/,b))"
    },
    "grepl": {
        "variant": "Function",
        "name": "grepl",
        "args": [
            "a_expr",
            "a_lines"
        ],
        "expr": "$grepl(a_expr,a_lines)",
        "desc": "Grep line from given lines. This returns all lines that matches given expression\n\n# Arguments\n\n- a_expr  : Regex expression to match\n- a_lines : Lines to get matches from\n\n# Example\n\n$assert(2,$countl($grepl(Cargo,$syscmd(ls))))"
    },
    "tab": {
        "variant": "Function",
        "name": "tab",
        "args": [
            "a_amount?^"
        ],
        "expr": "$tab(a_amount?^)",
        "desc": "Print tab\n\n# Arguments\n\n- a_amount : Amount of tabs to print [Unsigned integer] ( trimmed )\n\n# Example\n\n$tab(2)"
    },
    "eval": {
        "variant": "Function",
        "name": "eval",
        "args": [
            "a_expr"
        ],
        "expr": "$eval(a_expr)",
        "desc": "Evaluate a given expression\n\n- This macro redirects expression to evalexpr crate\n\n# Arguments\n\n- a_expr : Expression to evaluate\n\n# Example\n\n$assert(3,$eval(1 + 2))"
    },
    "spread": {
        "variant": "Deterred",
        "name": "spread",
        "args": [
            "a_macro_name^",
            "a_csv_value^"
        ],
        "expr": "$spread(a_macro_name^,a_csv_value^)",
        "desc": "Execute macro multiple times with given data chunk. Each csv line represent arguments for a macro\n\n# Arguments\n\n- a_macro_name : Macro name to execute ( trimmed ) \n- a_csv_value  : Arguments table ( trimmed )\n\n# Example\n\n$assert=(\n\ttext------\n\t---text---\n\t------text,\n\t$spread=(\n\t\talign,\n\t\tleft,10,-,text\n\t\tcenter,10,-,text\n\t\tright,10,-,text\n\t)\n)"
    },
    "find": {
        "variant": "Function",
        "name": "find",
        "args": [
            "a_expr",
            "a_source"
        ],
        "expr": "$find(a_expr,a_source)",
        "desc": "Find an occurrence of expression from source. This return boolean value\n\n# Return : Boolean\n\n# Arguments\n\n- a_expr   : Expression to match\n- a_source : Source to match for\n\n# Example\n\n$assert(true,$find(^abc,abcde))"
    },
    "logm": {
        "variant": "Deterred",
        "name": "logm",
        "args": [
            "a_macro_name^"
        ],
        "expr": "$logm(a_macro_name^)",
        "desc": "Log a macro information. Either print macro body of local or runtime macros.\n\n# Arguments\n\n- a_macro_name : Macro name to log (trimmed)\n\n# Example\n\n$define(test=Test)\n$logm(test)"
    },
    "extract": {
        "variant": "Function",
        "name": "extract",
        "args": [],
        "expr": "$extract()",
        "desc": "Extract from storage\n\n# Example\n\n$extract()"
    },
    "append": {
        "variant": "Function",
        "name": "append",
        "args": [
            "a_macro_name^",
            "a_content"
        ],
        "expr": "$append(a_macro_name^,a_content)",
        "desc": "Append contents to a macro. If macro doesn't exist, yields error\n\n# Arguments\n\n- a_macro_name : a macro name to append to ( trimmed )\n- a_content    : contents to be added\n\n# Example\n\n$define(container=Before)\n$append(container,$space()After)\n$assert($container(),Before After)"
    },
    "tail": {
        "variant": "Function",
        "name": "tail",
        "args": [
            "a_count^",
            "a_content"
        ],
        "expr": "$tail(a_count^,a_content)",
        "desc": "Get last parts of texts\n\n# Arguments\n\n- a_count   : Amount of characters to crop [unsigned integer] ( trimmed )\n- a_content : Text to crop from\n\n# Example\n\n$assert(World,$tail( 5 ,Hello~ World))"
    },
    "countl": {
        "variant": "Function",
        "name": "countl",
        "args": [
            "a_lines"
        ],
        "expr": "$countl(a_lines)",
        "desc": "Get counts of lines. This ignores empty line\n\n# Return : Unsigned integer\n\n# Arguments\n\n- a_lines : Lines to get counts from\n\n# Example\n\n$assert(3,$countl(1\n2\n3))"
    },
    "-": {
        "variant": "Function",
        "name": "-",
        "args": [
            "a_pipe_name?^"
        ],
        "expr": "$-(a_pipe_name?^)",
        "desc": "Get piped value. This truncates original value by default if not configured\n\n# Arguments\n\n- a_pipe_name : Name of pipe ( trimmed, optional )\n\n# Exmaple\n\n$eval|(1+2)\n$assert(3,$-())\n$nassert(3,$-())\n$pipeto(num,5)\n$assert(5,$-(num))"
    },
    "trimla": {
        "variant": "Function",
        "name": "trimla",
        "args": [
            "a_trim_option^",
            "a_content"
        ],
        "expr": "$trimla(a_trim_option^,a_content)",
        "desc": "Triml with given amount\n\n- Trims by line but with given amount. \n- If given integer it tries to trim blank characters as much as given value\n- min trims by minimal amount that can be applied to total lines\n- max acts same as triml\n- Tab character is calculated as a single character. Don't combine spaces and tabs for this macro\n\n# Arguments\n\n- a_trim_option : Trim behaviour [\"min\", \"max\", Unsigned integer] ( trimmed )\n\n# Example\n\n$trimla(min,$space(1)First\n$space(2)Second\n$space(3)Third)\n% ===\n% Equally strips one space\n% First\n%  Second\n%   Third\n\n\n$trimla(3,$space(2)First\n$space(3)Second\n$space(5)Third)\n% ===\n% Equally tries stripping 3 spaces\n% First\n% Second\n%   Third"
    },
    "temp": {
        "variant": "Function",
        "name": "temp",
        "args": [],
        "expr": "$temp()",
        "desc": "Get temp path\n\n- Default temporary path is folloiwng\n- Windows : It depends, but %APPDATA%\\Local\\Temp\\rad.txt can be one\n- *nix    : /tmp/rad.txt \n\n# Auth: FIN\n\n# Example\n\n$assert(/tmp/rad.txt,$temp())"
    },
    "query": {
        "variant": "Function",
        "name": "query",
        "args": [
            "a_query^"
        ],
        "expr": "$query(a_query^)",
        "desc": "Query a csv table\n\n- Syntax of the query resembles SQL\n- Refer cindex for detailed query syntax\n\n# Arguments\n\n- a_query : Query statement ( trimmed )\n\n# Example\n\n$query(SELECT * FROM TABLE WHERE name == john FLAG PHD)"
    },
    "tr": {
        "variant": "Function",
        "name": "tr",
        "args": [
            "a_chars",
            "a_sub",
            "a_source"
        ],
        "expr": "$tr(a_chars,a_sub,a_source)",
        "desc": "Translate characters. Usage similar to core util tr\n\n# Arguments\n\n- a_chars  : Matching characters\n- a_sub    : Substitute characters\n- a_source : Source text to apply translation\n\n# Example\n\n$assert(HellO_WOrld,$tr(-how,_HOW,hello-world))"
    },
    "pause": {
        "variant": "Function",
        "name": "pause",
        "args": [
            "a_pause?^"
        ],
        "expr": "$pause(a_pause?^)",
        "desc": "Pause a macro expansion from invocation. Paused processor will only expand $pause(false)\n\n- NOTE : Pause is not a flow control but a processor state, thus the state will sustain for the whole processing.\n\n# Arguments\n\n- a_pause : Whether to pause or not [boolean] ( trimmed )\n\n# Example\n\n$counter(i)\n$pause(true)\n$counter(i)\n$pause(false)\n\n$nassert(2,$i())\n$assert(1,$i())"
    },
    "undef": {
        "variant": "Function",
        "name": "undef",
        "args": [
            "a_macro_name^"
        ],
        "expr": "$undef(a_macro_name^)",
        "desc": "Undefine a macro\n\n- This undefines all macros that has a given name\n- Define macro cannot be undefined\n- Undef dodesn't yield error when macro doesn't exist\n\n# Arguments \n\n- a_macro_name : Name of a macro to undefine\n\n# Example\n\n$define(test=Test)\n$undef(test)\n$fassert($test())"
    },
    "ifenvel": {
        "variant": "Deterred",
        "name": "ifenvel",
        "args": [
            "a_env_name^",
            "a_if_expr",
            "a_else_expr"
        ],
        "expr": "$ifenvel(a_env_name^,a_if_expr,a_else_expr)",
        "desc": "Execute expression by whether environment variable is set or not\n\n# Auth : ENV\n\n# Arguments\n\n- a_env_name   : Environment variable ( trimmed )\n- a_if_expr    : Expression to expand if env exists\n- a_else_expr  : Expression to expand if env doesn't exist\n\n# Example\n\n$assert(I'm alive,$ifenvel(HOME,I'm alive,I'm dead))\n$assert(I'm dead,$ifenvel(EMOH,I'm alive,I'm dead))"
    },
    "let": {
        "variant": "Function",
        "name": "let",
        "args": [
            "a_macro_name^",
            "a_value^"
        ],
        "expr": "$let(a_macro_name^,a_value^)",
        "desc": "Bind a local macro. Every local macro gets removed after first level macro expansion ends.\n\n# Arguments\n\n- a_macro_name : Binding name to make ( trimmed )\n- a_value      : A value to bind to which is not trimmed ( trimmed )\n\n# Example\n\n$define(letr_test=\n    $let(lc,\n        --Bound Value--\n    )\n    $assert(1,$countl($lc()))\n)\n$letr_test()\n% Cannot access local macro outside the scope\n$fassert($lc())"
    }
}
